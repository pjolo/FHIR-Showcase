<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronos - 3D Adventure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #000; color: #fff; overflow: hidden; }
        #info { position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; z-index: 100; }
        #inventory { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; display: flex; gap: 10px; }
        .slot { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 2em; }
        .slot.filled { border-color: gold; background: rgba(255,215,0,0.2); }
        #message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 3px solid gold; border-radius: 15px; padding: 30px; display: none; z-index: 200; min-width: 400px; text-align: center; }
        #message h2 { color: gold; margin-bottom: 15px; }
        #message button { margin-top: 20px; padding: 10px 30px; background: gold; border: none; border-radius: 5px; cursor: pointer; font-size: 1.1em; }
        .puzzle { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 3px solid gold; border-radius: 15px; padding: 40px; display: none; z-index: 300; }
        .puzzle h2 { color: gold; margin-bottom: 20px; text-align: center; }
        .puzzle-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0; }
        .puzzle-btn { width: 80px; height: 80px; background: rgba(255,255,255,0.1); border: 2px solid #666; border-radius: 10px; font-size: 2em; cursor: pointer; }
        .puzzle-btn:hover { background: rgba(255,255,255,0.2); }
        .puzzle-btn.active { border-color: gold; background: rgba(255,215,0,0.3); }
        .close { position: absolute; top: 10px; right: 10px; background: red; border: none; color: white; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; }
    </style>
</head>
<body>
    <div id="info">
        <h3 id="world-name">üèùÔ∏è Strand</h3>
        <p>üñ±Ô∏è Rechtsklick + Ziehen: Umsehen<br>üñ±Ô∏è Linksklick: Interagieren<br>üéØ Finde Items und l√∂se R√§tsel!</p>
    </div>

    <div id="inventory">
        <div class="slot" id="slot0"></div>
        <div class="slot" id="slot1"></div>
        <div class="slot" id="slot2"></div>
        <div class="slot" id="slot3"></div>
    </div>

    <div id="message">
        <h2 id="msg-title"></h2>
        <p id="msg-text"></p>
        <button onclick="closeMessage()">OK</button>
    </div>

    <div id="symbol-puzzle" class="puzzle">
        <button class="close" onclick="closePuzzle('symbol-puzzle')">‚úï</button>
        <h2>üîÆ Symbol-R√§tsel</h2>
        <p style="text-align:center; margin-bottom:15px;">Klicke die Symbole in der richtigen Reihenfolge:<br>üåô ‚òÄÔ∏è ‚≠ê üåç</p>
        <div class="puzzle-grid">
            <button class="puzzle-btn" onclick="selectSymbol('üåô')">üåô</button>
            <button class="puzzle-btn" onclick="selectSymbol('‚òÄÔ∏è')">‚òÄÔ∏è</button>
            <button class="puzzle-btn" onclick="selectSymbol('‚≠ê')">‚≠ê</button>
            <button class="puzzle-btn" onclick="selectSymbol('üåç')">üåç</button>
            <button class="puzzle-btn" onclick="selectSymbol('üíé')">üíé</button>
            <button class="puzzle-btn" onclick="selectSymbol('üî•')">üî•</button>
            <button class="puzzle-btn" onclick="selectSymbol('üíß')">üíß</button>
            <button class="puzzle-btn" onclick="selectSymbol('üå™Ô∏è')">üå™Ô∏è</button>
        </div>
        <div style="text-align:center;">
            <p>Deine Auswahl: <span id="sequence"></span></p>
            <button onclick="checkSymbolPuzzle()" style="margin:15px 5px; padding:10px 30px; background:gold; border:none; border-radius:5px; cursor:pointer;">Pr√ºfen</button>
            <button onclick="resetSymbolPuzzle()" style="margin:15px 5px; padding:10px 30px; background:#666; color:white; border:none; border-radius:5px; cursor:pointer;">Reset</button>
        </div>
    </div>

    <div id="crystal-puzzle" class="puzzle">
        <button class="close" onclick="closePuzzle('crystal-puzzle')">‚úï</button>
        <h2>üíé Kristall-Muster</h2>
        <p style="text-align:center; margin-bottom:15px;">Aktiviere alle Kristalle (sie beeinflussen Nachbarn):</p>
        <div id="crystal-grid" style="display:grid; grid-template-columns:repeat(5,1fr); gap:10px; margin:20px 0;"></div>
        <div style="text-align:center;">
            <button onclick="resetCrystalPuzzle()" style="padding:10px 30px; background:#666; color:white; border:none; border-radius:5px; cursor:pointer;">Reset</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const gameState = {
            currentWorld: 'beach',
            inventory: [],
            symbolSequence: [],
            crystalPattern: Array(25).fill(false),
            puzzlesSolved: { symbol: false, crystal: false }
        };

        // Three.js Setup
        let scene, camera, renderer, controls;
        let clickableObjects = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(10, 20, 10);
            sunLight.castShadow = true;
            scene.add(sunLight);

            camera.position.set(0, 5, 15);

            // Simple controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 2) isDragging = true;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    camera.rotation.y += deltaX * 0.005;
                    camera.rotation.x += deltaY * 0.005;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            renderer.domElement.addEventListener('click', onClick);
            window.addEventListener('resize', onResize);

            createBeachWorld();
            animate();
        }

        function createBeachWorld() {
            clearScene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ color: 0xF4A460 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Water
            const water = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 50),
                new THREE.MeshStandardMaterial({ color: 0x4169E1, transparent: true, opacity: 0.7 })
            );
            water.rotation.x = -Math.PI / 2;
            water.position.z = -40;
            scene.add(water);

            // Palms
            for (let i = 0; i < 8; i++) {
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 5),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                );
                const leaves = new THREE.Mesh(
                    new THREE.SphereGeometry(2),
                    new THREE.MeshStandardMaterial({ color: 0x228B22 })
                );
                trunk.position.set((Math.random() - 0.5) * 40, 2.5, (Math.random() - 0.5) * 30);
                leaves.position.copy(trunk.position);
                leaves.position.y += 4;
                trunk.castShadow = true;
                leaves.castShadow = true;
                scene.add(trunk);
                scene.add(leaves);
            }

            // Key (if not collected)
            if (!gameState.inventory.includes('üîë')) {
                const key = new THREE.Mesh(
                    new THREE.TorusGeometry(0.5, 0.15, 16, 100),
                    new THREE.MeshStandardMaterial({ color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.5 })
                );
                key.position.set(8, 1, 5);
                key.rotation.x = Math.PI / 2;
                key.userData = { type: 'key' };
                scene.add(key);
                clickableObjects.push(key);
            }

            // Temple Door
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(4, 6, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            door.position.set(0, 3, -15);
            door.userData = { type: 'door' };
            door.castShadow = true;
            scene.add(door);
            clickableObjects.push(door);

            // Altar for symbol puzzle
            const altar = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2, 2),
                new THREE.MeshStandardMaterial({ color: 0x696969 })
            );
            altar.position.set(-8, 1, 0);
            altar.userData = { type: 'altar' };
            altar.castShadow = true;
            scene.add(altar);
            clickableObjects.push(altar);

            // Crystal Pedestal
            if (!gameState.inventory.includes('üíé') && gameState.puzzlesSolved.crystal) {
                const crystal = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.8),
                    new THREE.MeshStandardMaterial({ color: 0x00FFFF, emissive: 0x00FFFF, emissiveIntensity: 0.7 })
                );
                crystal.position.set(8, 2, -8);
                crystal.userData = { type: 'crystal' };
                scene.add(crystal);
                clickableObjects.push(crystal);
            }

            // Puzzle Pedestal
            const pedestal = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 2, 2),
                new THREE.MeshStandardMaterial({ color: 0x696969 })
            );
            pedestal.position.set(8, 1, -8);
            pedestal.userData = { type: 'pedestal' };
            scene.add(pedestal);
            clickableObjects.push(pedestal);
        }

        function clearScene() {
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            clickableObjects = [];
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                handleInteraction(obj.userData.type);
            }
        }

        function handleInteraction(type) {
            switch(type) {
                case 'key':
                    addToInventory('üîë');
                    showMessage('Schl√ºssel gefunden!', 'Du hast einen goldenen Schl√ºssel gefunden!');
                    createBeachWorld();
                    break;
                case 'door':
                    if (gameState.inventory.includes('üîë') && gameState.inventory.includes('üíé')) {
                        showMessage('üéâ Sieg!', 'Du hast alle R√§tsel gel√∂st und die T√ºr ge√∂ffnet!\n\nDie Zeitinsel gibt ihre Geheimnisse preis!');
                    } else if (gameState.inventory.includes('üîë')) {
                        showMessage('Fast geschafft!', 'Die T√ºr ist entsperrt, aber es fehlt noch etwas... Du brauchst den Kristall!');
                    } else {
                        showMessage('Verschlossen', 'Die T√ºr ist fest verschlossen. Du brauchst einen Schl√ºssel.');
                    }
                    break;
                case 'altar':
                    document.getElementById('symbol-puzzle').style.display = 'block';
                    break;
                case 'pedestal':
                    if (!gameState.puzzlesSolved.crystal) {
                        initCrystalPuzzle();
                        document.getElementById('crystal-puzzle').style.display = 'block';
                    }
                    break;
                case 'crystal':
                    addToInventory('üíé');
                    showMessage('Kristall erhalten!', 'Der leuchtende Zeitkristall ist nun dein!');
                    createBeachWorld();
                    break;
            }
        }

        function addToInventory(item) {
            if (!gameState.inventory.includes(item)) {
                gameState.inventory.push(item);
                updateInventory();
            }
        }

        function updateInventory() {
            gameState.inventory.forEach((item, i) => {
                const slot = document.getElementById('slot' + i);
                slot.textContent = item;
                slot.classList.add('filled');
            });
        }

        function showMessage(title, text) {
            document.getElementById('msg-title').textContent = title;
            document.getElementById('msg-text').textContent = text;
            document.getElementById('message').style.display = 'block';
        }

        function closeMessage() {
            document.getElementById('message').style.display = 'none';
        }

        function closePuzzle(id) {
            document.getElementById(id).style.display = 'none';
        }

        // Symbol Puzzle
        function selectSymbol(symbol) {
            if (gameState.symbolSequence.length < 4) {
                gameState.symbolSequence.push(symbol);
                document.getElementById('sequence').textContent = gameState.symbolSequence.join(' ');
            }
        }

        function checkSymbolPuzzle() {
            const correct = ['üåô', '‚òÄÔ∏è', '‚≠ê', 'üåç'];
            const isCorrect = JSON.stringify(gameState.symbolSequence) === JSON.stringify(correct);
            
            if (isCorrect) {
                gameState.puzzlesSolved.symbol = true;
                showMessage('‚úÖ R√§tsel gel√∂st!', 'Die Symbole leuchten auf! Du hast das R√§tsel gel√∂st!');
                closePuzzle('symbol-puzzle');
                resetSymbolPuzzle();
            } else {
                showMessage('‚ùå Falsch', 'Die Reihenfolge ist nicht korrekt. Versuche es erneut!');
                resetSymbolPuzzle();
            }
        }

        function resetSymbolPuzzle() {
            gameState.symbolSequence = [];
            document.getElementById('sequence').textContent = '';
        }

        // Crystal Puzzle
        function initCrystalPuzzle() {
            const grid = document.getElementById('crystal-grid');
            grid.innerHTML = '';
            gameState.crystalPattern = Array(25).fill(false);
            
            for (let i = 0; i < 25; i++) {
                const cell = document.createElement('div');
                cell.style.width = '60px';
                cell.style.height = '60px';
                cell.style.background = 'rgba(255,255,255,0.1)';
                cell.style.border = '2px solid #666';
                cell.style.borderRadius = '8px';
                cell.style.cursor = 'pointer';
                cell.dataset.index = i;
                cell.onclick = () => toggleCrystal(i);
                grid.appendChild(cell);
            }
        }

        function toggleCrystal(index) {
            const toggle = (i) => {
                if (i >= 0 && i < 25) {
                    gameState.crystalPattern[i] = !gameState.crystalPattern[i];
                }
            };

            toggle(index);
            toggle(index - 1); // left
            toggle(index + 1); // right
            toggle(index - 5); // up
            toggle(index + 5); // down

            updateCrystalDisplay();
            checkCrystalWin();
        }

        function updateCrystalDisplay() {
            const cells = document.getElementById('crystal-grid').children;
            gameState.crystalPattern.forEach((lit, i) => {
                cells[i].style.background = lit ? 'rgba(0,255,255,0.7)' : 'rgba(255,255,255,0.1)';
                cells[i].style.borderColor = lit ? '#00FFFF' : '#666';
                cells[i].style.boxShadow = lit ? '0 0 20px rgba(0,255,255,0.8)' : 'none';
            });
        }

        function checkCrystalWin() {
            if (gameState.crystalPattern.every(cell => cell)) {
                gameState.puzzlesSolved.crystal = true;
                showMessage('‚úÖ Kristall-R√§tsel gel√∂st!', 'Alle Kristalle leuchten! Der Zeitkristall erscheint!');
                closePuzzle('crystal-puzzle');
                createBeachWorld();
            }
        }

        function resetCrystalPuzzle() {
            gameState.crystalPattern = Array(25).fill(false);
            updateCrystalDisplay();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
